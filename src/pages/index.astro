---
import Layout from '~/layouts/BaseLayout.astro';
import { EscapeHtml } from '~/lib/utils';

const user = Astro.locals.user; // Get user from middleware
---

<Layout title="上传图片 - ImgBed">
  <header class="container mx-auto px-4 md:px-8 py-4 flex justify-between items-center gap-4">
    <a href="/" class="text-2xl font-bold">ImgBed</a>
    <div class="settings-section mt-8 text-center hidden md:block">
      {user ? (
        <a href="/admin" class="px-4 py-2 border bg-text text-background hover:opacity-90 rounded-md transition-opacity">前往后台</a>
      ) : (
        <a href="/login" class="px-4 py-2 border bg-text text-background hover:opacity-90 rounded-md transition-opacity">
          登录后台
        </a>
      )}
    </div>
  </header>
  <main class="container mx-auto p-4 md:p-8">
    <h1 class="text-3xl font-bold mb-8 text-center">图片上传</h1>

    <div class="upload-section border bg-background rounded-lg shadow-xl p-8 md:p-12 lg:p-14 mb-8">
      <div id="drop-zone" class="border-2 border-dashed border-border p-10 text-center cursor-pointer hover:border-text transition-colors rounded-lg">
        <p class="text-lg mb-2">拖拽文件到此处，点击选择，或直接粘贴图片</p>
        <p class="text-sm text-gray-700 mb-2">(支持批量上传)</p>
        <input type="file" id="file-input" multiple class="hidden" accept="image/*"/>
        <div id="selected-files-list" class="mt-2 text-sm text-gray-700"></div>
        <div id="pasted-image-previews" class="mt-4 flex flex-wrap gap-2 justify-center"></div> {/* New div for previews */}
      </div>

      <div class="mt-8">
        <label for="upload-directory" class="block font-medium mb-1">指定上传目录 (可选)</label>
        <input type="text" id="upload-directory" name="upload-directory" placeholder="例如：wallpapers/nature" class="w-full p-2 border border-border rounded-md bg-gray-100 focus:border-text focus:ring-1 focus:ring-text" />
      </div>

      <button id="upload-button" class="mt-6 w-full bg-text text-background py-2 px-4 border border-transparent hover:opacity-90 transition-opacity rounded-md">
        上传
      </button>
    </div>

    <div class="links-section border border-border bg-background rounded-lg shadow-xl p-6 md:p-8 hidden">
      <h2 class="text-2xl font-semibold mb-4">上传成功！</h2>
      <div id="uploaded-links" class="space-y-4">
        <!-- 上传后的链接将显示在这里 -->
      </div>
    </div>

    <div class="settings-section mt-8 text-center md:hidden">
      {user ? (
        <a href="/admin" class="px-4 py-2 border bg-text text-background hover:opacity-90 rounded-md transition-opacity">前往后台</a>
      ) : (
        <a href="/login" class="px-4 py-2 border bg-text text-background hover:opacity-90 rounded-md transition-opacity">
          登录后台
        </a>
      )}
    </div>
  </main>
</Layout>

<script>
  import { actions } from 'astro:actions';
  import { EscapeHtml } from "~/lib/utils";
  import { signal, computed, effect } from "@preact/signals-core";

  // DOM Elements
  const dropZone = document.getElementById('drop-zone') as HTMLElement | null;
  const fileInput = document.getElementById('file-input') as HTMLInputElement | null;
  const uploadButton = document.getElementById('upload-button') as HTMLButtonElement | null;
  const uploadDirectoryInput = document.getElementById('upload-directory') as HTMLInputElement | null;
  const linksSection = document.querySelector('.links-section') as HTMLElement | null;
  const uploadedLinksContainer = document.getElementById('uploaded-links') as HTMLElement | null;
  const linksSectionTitle = linksSection?.querySelector('h2') as HTMLHeadingElement | null;
  const selectedFilesList = document.getElementById('selected-files-list') as HTMLElement | null;
  const pastedImagePreviews = document.getElementById('pasted-image-previews') as HTMLElement | null;

  // Signals
  const currentFilesSignal = signal<File[]>([]);
  const uploadDirectorySignal = signal<string>("");
  const uploadingSignal = signal<boolean>(false);
  const uploadResultSignal = signal<{ message: string; files: UploadedFileResponse[]; error?: boolean } | null>(null);

  /**
   * Helper function to add new files to the currentFilesSignal, ensuring no duplicates.
   */
  function addFilesToSignal(newFilesArray: File[]) {
    if (newFilesArray.length === 0) return;

    const existingFiles = currentFilesSignal.value;
    // Filter for image types first, then for uniqueness
    const imageFiles = newFilesArray.filter(file => file.type.startsWith('image/'));
    
    const trulyNewFiles = imageFiles.filter(newFile =>
      !existingFiles.some(existingFile =>
        existingFile.name === newFile.name &&
        existingFile.size === newFile.size &&
        existingFile.lastModified === newFile.lastModified
      )
    );

    if (trulyNewFiles.length > 0) {
      currentFilesSignal.value = [...existingFiles, ...trulyNewFiles];
    }
  }

  // Computed signal for selected file names text
  const selectedFileNamesTextSignal = computed(() => {
    if (currentFilesSignal.value.length > 0) {
      let fileNames = currentFilesSignal.value.map(file => EscapeHtml(file.name)).join(', ');
      if (fileNames.length > 100) fileNames = fileNames.substring(0, 97) + '...';
      return `<strong>已选择 (${currentFilesSignal.value.length}):</strong> ${fileNames}`;
    }
    return '';
  });

  /**
   * Updates the hidden file input with the current selection of files.
   */
  function updateFileInput() {
    if (!fileInput) return;
    const dataTransfer = new DataTransfer();
    currentFilesSignal.value.forEach(file => dataTransfer.items.add(file));
    fileInput.files = dataTransfer.files;
  }

  // Effect to update file input and selected files list when currentFilesSignal changes
  effect(() => {
    updateFileInput();
    if (selectedFilesList) {
      selectedFilesList.innerHTML = selectedFileNamesTextSignal.value;
    }
  });
  
  // Effect to render pasted image previews when currentFilesSignal changes
  effect(() => {
    if (!pastedImagePreviews) return () => {}; // Return empty cleanup if no preview area

    const objectUrlsCreatedForListPreviews: string[] = []; // Declare the tracking array
    pastedImagePreviews.innerHTML = ''; // Clear previous previews
    
    currentFilesSignal.value.forEach((file, index) => {
      if (file.type.startsWith('image/')) { // Only preview image files
        const previewContainer = document.createElement('div');
        previewContainer.className = 'relative w-24 h-24 border border-border overflow-hidden cursor-pointer rounded-md';
        
        const img = document.createElement('img');
        const listPreviewImageUrl = URL.createObjectURL(file); // URL for the list preview
        objectUrlsCreatedForListPreviews.push(listPreviewImageUrl); // Track for cleanup by effect
        img.src = listPreviewImageUrl;
        img.alt = `预览 ${EscapeHtml(file.name)}`;
        img.className = 'w-full h-full object-cover';

        // Click to enlarge preview
        previewContainer.onclick = (e) => {
          e.stopPropagation(); // Prevent dropZone click
          
          const existingModal = document.getElementById('image-preview-modal');
          if (existingModal) existingModal.remove();

          const modalSpecificImageUrl = URL.createObjectURL(file); // Create a fresh, modal-specific ObjectURL

          const modal = document.createElement('div');
          modal.id = 'image-preview-modal';
          modal.style.position = 'fixed';
          modal.style.top = '0';
          modal.style.left = '0';
          modal.style.width = '100%';
          modal.style.height = '100%';
          modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
          modal.style.display = 'flex';
          modal.style.justifyContent = 'center';
          modal.style.alignItems = 'center';
          modal.style.zIndex = '1000'; 
          
          const modalImg = document.createElement('img');
          modalImg.src = modalSpecificImageUrl; // Use the modal-specific URL
          modalImg.alt = `放大预览 ${EscapeHtml(file.name)}`;
          modalImg.style.maxWidth = '90%';
          modalImg.style.maxHeight = '90%';
          modalImg.style.objectFit = 'contain';
          
          modal.appendChild(modalImg);
          document.body.appendChild(modal);
          
          modal.onclick = () => {
            modal.remove();
            URL.revokeObjectURL(modalSpecificImageUrl); // Revoke only the modal-specific URL
          };
        };
        
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'absolute top-0.5 right-0.5 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs leading-none hover:bg-red-700 focus:outline-none';
        removeBtn.innerHTML = '&times;';
        removeBtn.title = `移除 ${EscapeHtml(file.name)}`;
        removeBtn.onclick = (e) => {
          e.stopPropagation();
          const updatedFiles = [...currentFilesSignal.value];
          updatedFiles.splice(index, 1);
          currentFilesSignal.value = updatedFiles;
        };

        previewContainer.appendChild(img);
        previewContainer.appendChild(removeBtn);
        pastedImagePreviews.appendChild(previewContainer);
      }
    });

    // Cleanup function for this effect: revoke all ObjectURLs created for the list previews in this run
    return () => {
      objectUrlsCreatedForListPreviews.forEach((url: string) => URL.revokeObjectURL(url));
    };
  });

  /**
   * 处理剪贴板粘贴内容，支持多种格式的图片粘贴
   */
  async function handlePaste(event: ClipboardEvent) {
    if (!event.clipboardData) return;
    event.preventDefault();
    
    let processedAnyContent = false;
    const newFilesBatch: File[] = [];

    if (event.clipboardData.items) {
      const items = Array.from(event.clipboardData.items);
      for (const item of items) {
        if (item.kind === 'file' && item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) newFilesBatch.push(file);
          processedAnyContent = true;
        } else if (item.kind === 'string' && item.type === 'text/plain') {
          const text = await new Promise<string>(resolve => item.getAsString(resolve));
          if (text.match(/^https?:\/\/.*\.(jpe?g|png|gif|webp|svg)(\?.*)?$/i)) {
            try {
              const response = await fetch(text);
              if (!response.ok) continue;
              const blob = await response.blob();
              if (blob.type.startsWith('image/')) {
                const urlParts = text.split('/');
                let fileName = urlParts[urlParts.length - 1].split('?')[0] || 'image.jpg';
                const file = new File([blob], fileName, { type: blob.type });
                newFilesBatch.push(file);
                processedAnyContent = true;
              }
            } catch (e) {
              console.error('从URL获取图片失败:', e);
            }
          }
        }
      }
    }
    
    if (!processedAnyContent && event.clipboardData.items) {
        for (const item of event.clipboardData.items) {
            if (item.type.startsWith('image/')) {
                const blob = item.getAsFile();
                if (blob) {
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const extension = blob.type.split('/')[1] || 'png';
                    const fileName = `clipboard-image-${timestamp}.${extension}`;
                    const file = new File([blob], fileName, { type: blob.type });
                    newFilesBatch.push(file);
                    processedAnyContent = true;
                }
            }
        }
    }
    
    if (!processedAnyContent && event.clipboardData.getData('text/html')) {
      const html = event.clipboardData.getData('text/html');
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      const images = tempDiv.querySelectorAll('img');
      for (const img of images) {
        if (img.src.startsWith('data:image/')) {
          try {
            const response = await fetch(img.src);
            if (!response.ok) continue;
            const blob = await response.blob();
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const extension = blob.type.split('/')[1] || 'png';
            const fileName = `embedded-image-${timestamp}.${extension}`;
            const file = new File([blob], fileName, { type: blob.type });
            newFilesBatch.push(file);
          } catch (e) {
            console.error('处理嵌入图片失败:', e);
          }
        }
      }
    }

    if (newFilesBatch.length > 0) {
      addFilesToSignal(newFilesBatch); // Use the helper function
    }
  }
  
  dropZone?.addEventListener('paste', handlePaste);
  document.addEventListener('paste', handlePaste);

  dropZone?.addEventListener('click', () => fileInput?.click());

  dropZone?.addEventListener('dragover', (event) => {
    event.preventDefault();
    if (dropZone) dropZone.classList.add('border-text');
  });

  dropZone?.addEventListener('dragleave', () => {
    if (dropZone) dropZone.classList.remove('border-text');
  });

  dropZone?.addEventListener('drop', (event: DragEvent) => {
    event.preventDefault();
    if (dropZone) dropZone.classList.remove('border-text');
    if (event.dataTransfer?.files && event.dataTransfer.files.length > 0) {
      addFilesToSignal(Array.from(event.dataTransfer.files));
    }
  });

  fileInput?.addEventListener('change', () => {
    if (fileInput.files && fileInput.files.length > 0) {
      addFilesToSignal(Array.from(fileInput.files));
    }
    // If user cancels file dialog, fileInput.files will be empty.
    // We should not clear currentFilesSignal in this case if it already contains pasted files.
  });

  uploadDirectoryInput?.addEventListener('input', (e) => {
    uploadDirectorySignal.value = (e.target as HTMLInputElement).value;
  });

  /**
   * Handles the file upload process.
   */
  async function handleUpload() {
    if (currentFilesSignal.value.length === 0) {
      uploadResultSignal.value = { message: '请选择要上传的文件。', files: [], error: true };
      return;
    }

    uploadingSignal.value = true;
    uploadResultSignal.value = null; // Clear previous messages

    const formData = new FormData();
    currentFilesSignal.value.forEach(file => formData.append('files', file));
    
    const uploadDir = uploadDirectorySignal.value.trim();
    if (uploadDir) {
      formData.append('uploadDirectory', uploadDir);
    }
      
    try {
      const { data, error } = await actions.upload(formData);

      if (error) {
        let errorMessage = error.message;
        if (error.code === 'BAD_REQUEST' && (error as any).fields) {
            const fieldErrors = Object.values((error as any).fields).flat().join(', ');
            errorMessage = fieldErrors || error.message;
        }
        throw new Error(errorMessage);
      }
      
      const result = data as { message: string; files: UploadedFileResponse[] };
      uploadResultSignal.value = { message: result.message || `${result.files.length} 个文件上传成功！`, files: result.files };
      currentFilesSignal.value = []; // Clear files after successful upload

    } catch (error: any) {
      console.error('Upload error:', error.message);
      uploadResultSignal.value = { message: `上传失败: ${error.message}`, files: [], error: true };
    } finally {
      uploadingSignal.value = false;
    }
  }
  uploadButton?.addEventListener('click', handleUpload);

  // Effect to update upload button state and text
  effect(() => {
    if (uploadButton) {
      uploadButton.disabled = uploadingSignal.value;
      if (uploadingSignal.value) {
        uploadButton.textContent = `正在上传 ${currentFilesSignal.value.length} 个文件...`;
      } else {
        uploadButton.textContent = '上传';
      }
    }
  });

  // Effect to display upload messages and results
  effect(() => {
    if (!linksSection || !linksSectionTitle || !uploadedLinksContainer) return;
    const result = uploadResultSignal.value;

    if (result) {
      linksSectionTitle.textContent = result.error ? '上传出错' : (result.files.length > 0 ? '上传成功！' : '操作结果');
      
      if (result.files.length > 0) {
        uploadedLinksContainer.innerHTML = ''; // Clear previous links
        result.files.forEach((uploadedFile) => {
          const linkGroup = document.createElement('div');
          linkGroup.className = 'link-group p-4 border border-border rounded-md';
          
          const nameElement = document.createElement('p');
          nameElement.className = 'font-medium mb-2 break-all';
          nameElement.textContent = uploadedFile.fileName;
          linkGroup.appendChild(nameElement);

          const linksDiv = document.createElement('div');
          linksDiv.className = 'space-y-2';
          
          const defaultCopyFormat = localStorage.getItem('defaultCopyFormat') || 'url'; 
          let autoCopiedThisUpload = false;

          const createLinkInput = (label: string, value: string, formatKey: string) => {
            const div = document.createElement('div');
            const labelSpan = document.createElement('span');
            labelSpan.className = 'font-semibold text-sm';
            labelSpan.textContent = `${label}: `;
            div.appendChild(labelSpan);
            
            const input = document.createElement('input');
            input.type = 'text';
            input.readOnly = true;
            input.value = value;
            input.className = 'w-full p-1.5 border border-border rounded-md bg-gray-100 focus:border-text focus:ring-1 focus:ring-text text-sm';
            input.addEventListener('focus', () => input.select());
            
            const feedbackSpan = document.createElement('span');
            feedbackSpan.className = 'text-xs text-green-500 ml-2 hidden';
            feedbackSpan.textContent = '已复制!';
            
            input.addEventListener('click', () => { 
                navigator.clipboard.writeText(value).then(() => {
                    feedbackSpan.classList.remove('hidden');
                    setTimeout(() => feedbackSpan.classList.add('hidden'), 1500);
                }).catch(err => {
                    console.error(`Could not copy ${label}: `, err);
                    feedbackSpan.textContent = '复制失败';
                    feedbackSpan.className = 'text-xs text-red-500 ml-2';
                    feedbackSpan.classList.remove('hidden');
                    setTimeout(() => {
                        feedbackSpan.classList.add('hidden');
                        feedbackSpan.textContent = '已复制!';
                        feedbackSpan.className = 'text-xs text-green-500 ml-2 hidden';
                    }, 2000);
                });
            });
            div.appendChild(input);
            div.appendChild(feedbackSpan);
            linksDiv.appendChild(div);

            if (!autoCopiedThisUpload && formatKey.toLowerCase() === defaultCopyFormat.toLowerCase()) {
              navigator.clipboard.writeText(value).then(() => {
                autoCopiedThisUpload = true;
                feedbackSpan.classList.remove('hidden');
                setTimeout(() => feedbackSpan.classList.add('hidden'), 1500);
              }).catch(err => console.error(`Could not auto-copy ${label}: `, err));
            }
          };
          
          const url = uploadedFile.url;
          const md = `![${EscapeHtml(uploadedFile.fileName)}](${url})`;
          const html = `<img src="${url}" alt="${EscapeHtml(uploadedFile.fileName)}" />`;

          createLinkInput('URL', url, 'url');
          createLinkInput('Markdown', md, 'markdown');
          createLinkInput('HTML', html, 'html');

          linkGroup.appendChild(linksDiv);
          uploadedLinksContainer.appendChild(linkGroup);
        });
      } else {
         uploadedLinksContainer.innerHTML = `<p class="${result.error ? 'text-red-500' : 'text-green-600'}">${EscapeHtml(result.message)}</p>`;
      }
      linksSection.classList.remove('hidden');
    } else {
      // Clear and hide if no result
      linksSectionTitle.textContent = '';
      uploadedLinksContainer.innerHTML = '';
      linksSection.classList.add('hidden');
    }
  });

  // Define UploadedFileResponse interface
  interface UploadedFileResponse {
    id: string;
    r2Key: string;
    fileName: string;
    contentType: string;
    size: number;
    uploadedAt: string;
    userId?: string;
    uploadPath?: string;
    url: string;
  }
</script>
